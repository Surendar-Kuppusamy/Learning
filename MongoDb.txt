MongoDB:
--------
*) MongoDB is an open-source document database and leading NoSQL database. MongoDB is written in C++.
*) MongoDB is a cross-platform, document oriented database that provides, high performance, high availability, and easy scalability. MongoDB works on concept of collection and document.

RockMongo:
----------
RockMongo is a MongoDB administration tool using which you can manage your server, databases, collections, documents, indexes, and a lot more. It provides a very user-friendly way for reading, writing, and creating documents. It is similar to PHPMyAdmin tool for PHP and MySQL.

Reference Link => "https://www.tutorialspoint.com/mongodb/working_with_rockmongo.htm"

Database:
---------
Database is a physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases.

Collection:
-----------
Collection is a group of MongoDB documents. It is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose.

Advantages of MongoDB over RDBMS:
---------------------------------
#) Schema less
#) Ease of scale-out
#) Structure of a single object is clear.
#) No complex joins.
#) Uses internal memory for storing the (windowed) working set, enabling faster access of data.


Text Index:
------------
*) It is used to create text index in any one of the field in collection. Once created, then we can search text without mention the fields, like below.

Create schema like this,

city_name: {
	type: String,
	text: true	//Its important for it
}

and below
CitySchema.index({ city_name: 1 }); // schema level

In command prompt,
db.cities.getIndexes()
db.cities.dropIndex(name)

aggrecate:
----------
{
	$match: {
		$text: {
			$search: keyword
		}
	}
},

Installation Process:
---------------------

Reference Link	=>	"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/"
https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/#std-label-run-mongodb-from-cmd

* Installed Mongodb as windows service.
* Mention your custom data path.
* Choosed Complete option

Open Mongodb Instruction:

i) Go path => "C:\Program Files\MongoDB\Server\4.4\bin\mongod.exe"
ii) Execute path "mongo"


Data MOdeling:
--------------
Data in MongoDB has a flexible schema.documents in the same collection. They do not need to have the same set of fields or structure Common fields in a collection?s documents may hold different types of data.
MongoDB provides two types of data models:
i) Embedded data model
ii) Normalized data model
Based on the requirement, you can use either of the models while preparing your document.

Embedded Data Model:
---------------------

In this model, you can have (embed) all the related data in a single document, it is also known as de-normalized data model.

Example:
--------

For example, assume we are getting the details of employees in three different documents namely, Personal_details, Contact and, Address, you can embed all the three documents in a single one as shown below ?

{
_id: ,
Emp_ID: "10025AE336"
Personal_details:{
First_Name: "Radhika",
Last_Name: "Sharma",
Date_Of_Birth: "1995-09-26"
},
Contact: {
e-mail: "radhika_sharma.123@gmail.com",
phone: "9848022338"
},
Address: {
city: "Hyderabad",
Area: "Madapur",
State: "Telangana"
}
}

Normalized Data Model:
----------------------

In this model, you can refer the sub documents in the original document, using references. For example, you can re-write the above document in the normalized model as:

Example:
--------

Employee:

{
_id: ,
Emp_ID: "10025AE336"
}

Personal_details:

{
_id: ,
empDocID: " ObjectId101",
First_Name: "Radhika",
Last_Name: "Sharma",
Date_Of_Birth: "1995-09-26"
}

Contact:

{
_id: ,
empDocID: " ObjectId101",
e-mail: "radhika_sharma.123@gmail.com",
phone: "9848022338"
}

Address:

{
_id: ,
empDocID: " ObjectId101",
city: "Hyderabad",
Area: "Madapur",
State: "Telangana"
}


Considerations while designing Schema in MongoDB:
-------------------------------------------------
-> Design your schema according to user requirements.

-> Combine objects into one document if you will use them together. Otherwise separate them (but make sure there should not be need of joins).

-> Duplicate the data (but limited) because disk space is cheap as compare to compute time.

-> Do joins while write, not on read.

-> Optimize your schema for most frequent use cases.

-> Do complex aggregation in the schema.


Commands and Actions:
----------------------
Database Actions:
-----------------
"use DATABASE_NAME"

*) MongoDB use DATABASE_NAME is used to create database. The command will create a new database if it doesn't exist, otherwise it will return the existing database.

"db"

*) To check your currently selected database, use the command db

"show dbs"

*) If you want to check your databases list, use the command show dbs.
*) Your created database (mydb) is not present in list. To display database, you need to insert at least one document into it.

>"db.movie.insert({"name":"tutorials point"})"
>"show dbs
local 0.78125GB
mydb 0.23012GB
test 0.23012GB"

In MongoDB default database is test. If you didn't create any database, then collections will be stored in test database. Above "movie" database is not created.

"db.dropDatabase()"

*) This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.

Collections: (It is like table in mysql)
------------
"db.createCollection(name, options)" => Syntax

Parameter Type Description
Name String Name of the collection to be created
Options Document (Optional) Specify options about memory size and indexing

Field Type Description
capped Boolean (Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites
its oldest entries when it reaches its maximum size. If you specify true, you need to specify size parameter also.
autoIndexId Boolean (Optional) If true, automatically create index on _id fields. Default value is false.
size number (Optional) Specifies a maximum size in bytes for a capped collection. If capped is true, then you need to specify this
field also.
max number (Optional) Specifies the maximum number of documents allowed in the capped collection.

Example:
--------

db.createCollection("mycol", { capped : true, autoIndexID : true, size : 6142800, max : 10000 } )

*) In MongoDB, you don't need to create collection. MongoDB creates collection automatically, when you insert some document.

Example:
--------

">db.tutorialspoint.insert({"name" : "tutorialspoint"}),
WriteResult({ "nInserted" : 1 })"
">show collections
mycol
mycollection
system.indexes
tutorialspoint
>"

Above "tutorialspoint" collections is not created, but it automatically created when you insert data.

Drop Collections:
-----------------

"db.COLLECTION_NAME.drop()" => Syntax

Example:
--------

">db.mycollection.drop()
true
>"

Data Types:
-----------
It supports many data types, check it on this link "https://www.tutorialspoint.com/mongodb/mongodb_datatype.htm".

String ? This is the most commonly used datatype to store the data. String in MongoDB must be UTF-8 valid.

Integer ? This type is used to store a numerical value. Integer can be 32 bit or 64 bit depending upon your server.

Boolean ? This type is used to store a boolean (true/ false) value.

Double ? This type is used to store floating point values.

Min/ Max keys ? This type is used to compare a value against the lowest and highest BSON elements.

Arrays ? This type is used to store arrays or list or multiple values into one key.

Timestamp ? ctimestamp. This can be handy for recording when a document has been modified or added.

Object ? This datatype is used for embedded documents.

Null ? This type is used to store a Null value.

Symbol ? This datatype is used identically to a string; however, it's generally reserved for languages that use a specific symbol type.

Date ? This datatype is used to store the current date or time in UNIX time format. You can specify your own date time by creating object of Date and passing day, month, year into it.

Object ID ? This datatype is used to store the document?s ID.

Binary data ? This datatype is used to store binary data.

Code ? This datatype is used to store JavaScript code into the document.

Regular expression ? This datatype is used to store regular expression.


Data Insert:
------------

To insert data into MongoDB collection, you need to use MongoDB's insert() or save() method.

Syntax:
-------
db.COLLECTION_NAME.insert(document)

Example:
--------

> db.createCollection("post")
> db.post.insert([
{
title: "MongoDB Overview",
description: "MongoDB is no SQL database",
by: "tutorials point",
url: "http://www.tutorialspoint.com",
tags: ["mongodb", "database", "NoSQL"],
likes: 100
},
{
title: "NoSQL Database",
description: "NoSQL database doesn't have tables",
by: "tutorials point",
url: "http://www.tutorialspoint.com",
tags: ["mongodb", "database", "NoSQL"],
likes: 20,
comments: [
{
user:"user1",
message: "My first comment",
dateCreated: new Date(2013,11,10,2,35),
like: 0
}
]
}
])

*) To insert the document you can use db.post.save(document) also. If you don't specify _id in the document then save() method will work same as insert() method. If you specify _id then it will replace whole data of document containing _id as specified in save() method.


If you need to insert only one document into a collection you can use this method.

Syntax:
-------
>db.COLLECTION_NAME.insertOne(document)


You can insert multiple documents using the insertMany() method. To this method you need to pass an array of documents.

Example:
--------

> db.empDetails.insertMany(
[
{
First_Name: "Radhika",
Last_Name: "Sharma",
Date_Of_Birth: "1995-09-26",
e_mail: "radhika_sharma.123@gmail.com",
phone: "9000012345"
},
{
First_Name: "Rachel",
Last_Name: "Christopher",
Date_Of_Birth: "1990-02-16",
e_mail: "Rachel_Christopher.123@gmail.com",
phone: "9000054321"
},
{
First_Name: "Fathima",
Last_Name: "Sheik",
Date_Of_Birth: "1990-02-16",
e_mail: "Fathima_Sheik.123@gmail.com",
phone: "9000054321"
}
]
)

Query or Fetch data from collections:
-------------------------------------

To query data from MongoDB collection, you need to use MongoDB's find() method.

Syntax:
-------

>db.COLLECTION_NAME.find()

Example:
--------

Step 1:
-------

> use sampleDB
switched to db sampleDB
> db.createCollection("mycol")
{ "ok" : 1 }
>

Step 2:
-------

> db.mycol.insert([
{
title: "MongoDB Overview",
description: "MongoDB is no SQL database",
by: "tutorials point",
url: "http://www.tutorialspoint.com",
tags: ["mongodb", "database", "NoSQL"],
likes: 100
},
{
title: "NoSQL Database",
description: "NoSQL database doesn't have tables",
by: "tutorials point",
url: "http://www.tutorialspoint.com",
tags: ["mongodb", "database", "NoSQL"],
likes: 20,
comments: [
{
user:"user1",
message: "My first comment",
dateCreated: new Date(2013,11,10,2,35),
like: 0
}
]
}
])

Step 3:
-------

> db.mycol.find()
{ "_id" : ObjectId("5dd4e2cc0821d3b44607534c"), "title" : "MongoDB Overview", "description" : "MongoDB is no SQL database", "by" : "tutorials point", "url" : "http://www.tutorialspoint.com", "tags" : [ "mongodb", "database", "NoSQL" ], "likes" : 100 }
{ "_id" : ObjectId("5dd4e2cc0821d3b44607534d"), "title" : "NoSQL Database", "description" : "NoSQL database doesn't have tables", "by" : "tutorials point", "url" : "http://www.tutorialspoint.com", "tags" : [ "mongodb", "database", "NoSQL" ], "likes" : 20, "comments" : [ { "user" : "user1", "message" : "My first comment", "dateCreated" : ISODate("2013-12-09T21:05:00Z"), "like" : 0 } ] }
>

*) To display the results in a formatted way, you can use pretty() method.

> db.mycol.find().pretty()
{
"_id" : ObjectId("5dd4e2cc0821d3b44607534c"),
"title" : "MongoDB Overview",
"description" : "MongoDB is no SQL database",
"by" : "tutorials point",
"url" : "http://www.tutorialspoint.com",
"tags" : [
"mongodb",
"database",
"NoSQL"
],
"likes" : 100
}
{
"_id" : ObjectId("5dd4e2cc0821d3b44607534d"),
"title" : "NoSQL Database",
"description" : "NoSQL database doesn't have tables",
"by" : "tutorials point",
"url" : "http://www.tutorialspoint.com",
"tags" : [
"mongodb",
"database",
"NoSQL"
],
"likes" : 20,
"comments" : [
{
"user" : "user1",
"message" : "My first comment",
"dateCreated" : ISODate("2013-12-09T21:05:00Z"),
"like" : 0
}
]
}

*) Apart from the find() method, there is findOne() method, that returns only one document.

Syntax:
-------
>db.COLLECTIONNAME.findOne()

Example:
--------
> db.mycol.findOne({title: "MongoDB Overview"})
{
"_id" : ObjectId("5dd6542170fb13eec3963bf0"),
"title" : "MongoDB Overview",
"description" : "MongoDB is no SQL database",
"by" : "tutorials point",
"url" : "http://www.tutorialspoint.com",
"tags" : [
"mongodb",
"database",
"NoSQL"
],
"likes" : 100
}

Where in query using mangodb:
-----------------------------

Refer this link "https://www.tutorialspoint.com/mongodb/mongodb_query_document.htm" and visit end of the page.

RDBMS Where Clause Equivalents in MongoDB

To query the document on the basis of some condition, you can use following operations.

Operation Syntax Example RDBMS Equivalent
Equality {:{$eg;}} db.mycol.find({"by":"tutorials point"}).pretty() where by =
'tutorials point'
Less Than {:{$lt:}} db.mycol.find({"likes":{$lt:50}}).pretty() where likes < 50
Less Than Equals {:{$lte:}} db.mycol.find({"likes":{$lte:50}}).pretty() where likes <= 50
Greater Than {:{$gt:}} db.mycol.find({"likes":{$gt:50}}).pretty() where likes > 50
Greater Than Equals {:{$gte:}} db.mycol.find({"likes":{$gte:50}}).pretty() where likes >= 50
Not Equals {:{$ne:}} db.mycol.find({"likes":{$ne:50}}).pretty() where likes != 50
Values in an array {:{$in:[, ,??]}} db.mycol.find({"name":{$in:["Raj", "Ram", "Raghu"]}}).pretty() Where name
matches any of
the value in
:["Raj", "Ram", "Raghu"]
Values not in an array {:{$nin:}} db.mycol.find({"name":{$nin:["Ramu", "Raghav"]}}).pretty() Where name
values is not in the array :["Ramu", "Raghav"] or, doesn?t exist at all

AND in MongoDB:
---------------

Syntax:
-------

To query documents based on the AND condition, you need to use $and keyword. Following is the basic syntax of AND ?

>db.mycol.find({ $and: [ {:}, { :} ] })

Example:
--------

Following example will show all the tutorials written by 'tutorials point' and whose title is 'MongoDB Overview'.

> db.mycol.find({$and:[{"by":"tutorials point"},{"title": "MongoDB Overview"}]}).pretty()
{
"_id" : ObjectId("5dd4e2cc0821d3b44607534c"),
"title" : "MongoDB Overview",
"description" : "MongoDB is no SQL database",
"by" : "tutorials point",
"url" : "http://www.tutorialspoint.com",
"tags" : [
"mongodb",
"database",
"NoSQL"
],
"likes" : 100
}
>

For the above given example, equivalent where clause will be ' where by = 'tutorials point' AND title = 'MongoDB Overview' '. You can pass any number of key, value pairs in find clause.


OR in MongoDB:
--------------

Syntax:
-------

To query documents based on the OR condition, you need to use $or keyword. Following is the basic syntax of OR ?

>db.mycol.find(
{
$or: [
{key1: value1}, {key2:value2}
]
}
).pretty()

Example:
--------

Following example will show all the tutorials written by 'tutorials point' or whose title is 'MongoDB Overview'.

>db.mycol.find({$or:[{"by":"tutorials point"},{"title": "MongoDB Overview"}]}).pretty()
{
"_id": ObjectId(7df78ad8902c),
"title": "MongoDB Overview",
"description": "MongoDB is no sql database",
"by": "tutorials point",
"url": "http://www.tutorialspoint.com",
"tags": ["mongodb", "database", "NoSQL"],
"likes": "100"
}
>


Using AND and OR Together:
--------------------------

Example:
--------

The following example will show the documents that have likes greater than 10 and whose title is either 'MongoDB Overview' or by is 'tutorials point'. Equivalent SQL where clause is 'where likes>10 AND (by = 'tutorials point' OR title = 'MongoDB Overview')'

>db.mycol.find({"likes": {$gt:10}, $or: [{"by": "tutorials point"},
{"title": "MongoDB Overview"}]}).pretty()
{
"_id": ObjectId(7df78ad8902c),
"title": "MongoDB Overview",
"description": "MongoDB is no sql database",
"by": "tutorials point",
"url": "http://www.tutorialspoint.com",
"tags": ["mongodb", "database", "NoSQL"],
"likes": "100"
}
>

NOR in MongoDB:
---------------

Syntax:
-------

To query documents based on the NOT condition, you need to use $not keyword. Following is the basic syntax of NOT ?

>db.COLLECTION_NAME.find(
{
$not: [
{key1: value1}, {key2:value2}
]
}
)

Example:
--------

Assume we have inserted 3 documents in the collection empDetails as shown below ?

db.empDetails.insertMany(
[
{
First_Name: "Radhika",
Last_Name: "Sharma",
Age: "26",
e_mail: "radhika_sharma.123@gmail.com",
phone: "9000012345"
},
{
First_Name: "Rachel",
Last_Name: "Christopher",
Age: "27",
e_mail: "Rachel_Christopher.123@gmail.com",
phone: "9000054321"
},
{
First_Name: "Fathima",
Last_Name: "Sheik",
Age: "24",
e_mail: "Fathima_Sheik.123@gmail.com",
phone: "9000054321"
}
]
)

Following example will retrieve the document(s) whose first name is not "Radhika" and last name is not "Christopher"

> db.empDetails.find(
{
$nor:[
40
{"First_Name": "Radhika"},
{"Last_Name": "Christopher"}
]
}
).pretty()
{
"_id" : ObjectId("5dd631f270fb13eec3963bef"),
"First_Name" : "Fathima",
"Last_Name" : "Sheik",
"Age" : "24",
"e_mail" : "Fathima_Sheik.123@gmail.com",
"phone" : "9000054321"
}

NOT in MongoDB:
---------------

Syntax:
-------

To query documents based on the NOT condition, you need to use $not keyword following is the basic syntax of NOT ?

>db.COLLECTION_NAME.find(
{
$NOT: [
{key1: value1}, {key2:value2}
]
}
).pretty()

Example:
--------

Following example will retrieve the document(s) whose age is not greater than 25

> db.empDetails.find( { "Age": { $not: { $gt: "25" } } } )
{
"_id" : ObjectId("5dd6636870fb13eec3963bf7"),
"First_Name" : "Fathima",
"Last_Name" : "Sheik",
"Age" : "24",
"e_mail" : "Fathima_Sheik.123@gmail.com",
"phone" : "9000054321"
}


Mangodb Update:
---------------

MongoDB's update() and save() methods are used to update document into a collection. The update() method updates the values in the existing document while the save() method replaces the existing document with the document passed in save() method.


MongoDB Update() Method:
------------------------

The update() method updates the values in the existing document only, if you try to add extra field or key, it fails.

Syntax:
-------

The basic syntax of update() method is as follows ?

>db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)

Example:
--------

Consider the mycol collection has the following data.

{ "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"}
{ "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"}
{ "_id" : ObjectId(5983548781331adf45ec7), "title":"Tutorials Point Overview"}

Following example will set the new title 'New MongoDB Tutorial' of the documents whose title is 'MongoDB Overview'.

>db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
>db.mycol.find()
{ "_id" : ObjectId(5983548781331adf45ec5), "title":"New MongoDB Tutorial"}
{ "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"}
{ "_id" : ObjectId(5983548781331adf45ec7), "title":"Tutorials Point Overview"}
>

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

*) By default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.

>db.mycol.update({'title':'MongoDB Overview'},
{$set:{'title':'New MongoDB Tutorial'}},{multi:true})

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


MongoDB Save() Method:
----------------------

The save() method replaces the existing document with the new document passed in the save() method, here we can add fileds or keys along with update.

Syntax:
-------

The basic syntax of MongoDB save() method is shown below ?

>db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})

Example:
--------

Following example will replace the document with the _id '5983548781331adf45ec5'.

>db.mycol.save(
{
"_id" : ObjectId("507f191e810c19729de860ea"),
"title":"Tutorials Point New Topic",
"by":"Tutorials Point"
}
)
WriteResult({
"nMatched" : 0,
"nUpserted" : 1,
"nModified" : 0,
"_id" : ObjectId("507f191e810c19729de860ea")
})
>db.mycol.find()
{ "_id" : ObjectId("507f191e810c19729de860e6"), "title":"Tutorials Point New Topic",
"by":"Tutorials Point"}
{ "_id" : ObjectId("507f191e810c19729de860e6"), "title":"NoSQL Overview"}
{ "_id" : ObjectId("507f191e810c19729de860e6"), "title":"Tutorials Point Overview"}
>

MongoDB findOneAndUpdate() method:
----------------------------------

The findOneAndUpdate() method updates the values in the existing document.

Syntax:
-------

The basic syntax of findOneAndUpdate() method is as follows ?

>db.COLLECTION_NAME.findOneAndUpdate(SELECTIOIN_CRITERIA, UPDATED_DATA)

Example:
--------

Assume we have created a collection named empDetails and inserted three documents in it as shown below ?

> db.empDetails.insertMany(
[
{
First_Name: "Radhika",
Last_Name: "Sharma",
Age: "26",
e_mail: "radhika_sharma.123@gmail.com",
phone: "9000012345"
},
{
First_Name: "Rachel",
Last_Name: "Christopher",
Age: "27",
e_mail: "Rachel_Christopher.123@gmail.com",
phone: "9000054321"
},
{
First_Name: "Fathima",
Last_Name: "Sheik",
Age: "24",
e_mail: "Fathima_Sheik.123@gmail.com",
phone: "9000054321"
}
]
)

Following example updates the age and email values of the document with name 'Radhika'.

> db.empDetails.findOneAndUpdate(
{First_Name: 'Radhika'},
{ $set: { Age: '30',e_mail: 'radhika_newemail@gmail.com'}}
)
{
"_id" : ObjectId("5dd6636870fb13eec3963bf5"),
"First_Name" : "Radhika",
"Last_Name" : "Sharma",
"Age" : "30",
"e_mail" : "radhika_newemail@gmail.com",
"phone" : "9000012345"
}


MongoDB updateOne() method:
---------------------------

This methods updates a single document which matches the given filter.

Syntax:
-------

The basic syntax of updateOne() method is as follows ?

>db.COLLECTION_NAME.updateOne(, )

Example:
--------

> db.empDetails.updateOne(
{First_Name: 'Radhika'},
{ $set: { Age: '30',e_mail: 'radhika_newemail@gmail.com'}}
)
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 0 }
>

MongoDB updateMany() method:
----------------------------

The updateMany() method updates all the documents that matches the given filter.

Syntax:
-------

The basic syntax of updateMany() method is as follows ?

>db.COLLECTION_NAME.update(, )

Example:
--------

> db.empDetails.updateMany(
{Age:{ $gt: "25" }},
{ $set: { Age: '00'}}
)
{ "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }

You can see the updated values if you retrieve the contents of the document using the find method as shown below ?

> db.empDetails.find()
{ "_id" : ObjectId("5dd6636870fb13eec3963bf5"), "First_Name" : "Radhika", "Last_Name" : "Sharma", "Age" : "00", "e_mail" : "radhika_newemail@gmail.com", "phone" : "9000012345" }
{ "_id" : ObjectId("5dd6636870fb13eec3963bf6"), "First_Name" : "Rachel", "Last_Name" : "Christopher", "Age" : "00", "e_mail" : "Rachel_Christopher.123@gmail.com", "phone" : "9000054321" }
{ "_id" : ObjectId("5dd6636870fb13eec3963bf7"), "First_Name" : "Fathima", "Last_Name" : "Sheik", "Age" : "24", "e_mail" : "Fathima_Sheik.123@gmail.com", "phone" : "9000054321" }
>

Mangodb remove():
-----------------
MongoDB's remove() method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.

-> deletion criteria ? (Optional) deletion criteria according to documents will be removed.

-> justOne ? (Optional) if set to true or 1, then remove only one document.

Syntax:
-------

Basic syntax of remove() method is as follows ?

>db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)

Example:
--------

Consider the mycol collection has the following data.

{_id : ObjectId("507f191e810c19729de860e1"), title: "MongoDB Overview"},
{_id : ObjectId("507f191e810c19729de860e2"), title: "NoSQL Overview"},
{_id : ObjectId("507f191e810c19729de860e3"), title: "Tutorials Point Overview"}

Following example will remove all the documents whose title is 'MongoDB Overview'.

>db.mycol.remove({'title':'MongoDB Overview'})
WriteResult({"nRemoved" : 1})
> db.mycol.find()
{"_id" : ObjectId("507f191e810c19729de860e2"), "title" : "NoSQL Overview" }
{"_id" : ObjectId("507f191e810c19729de860e3"), "title" : "Tutorials Point Overview" }


Remove Only One:
----------------

If there are multiple records and you want to delete only the first record, then set justOne parameter in remove() method.

Syntax:
-------
>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)

Remove All Documents:
---------------------

If you don't specify deletion criteria, then MongoDB will delete whole documents from the collection. This is equivalent of SQL's truncate command.

Example:
--------

> db.mycol.remove({})
WriteResult({ "nRemoved" : 2 })
> db.mycol.find()
>

Projection:
-----------

In MongoDB, projection means selecting only the necessary data rather than selecting whole of the data of a document. If a document has 5 fields and you need to show only 3, then select only 3 fields from them.

In MongoDB, when you execute find() method, then it displays all fields of a document. To limit this, you need to set a list of fields with value 1 or 0. 1 is used to show the field while 0 is used to hide the fields.

Syntax:
-------

The basic syntax of find() method with projection is as follows ?

>db.COLLECTION_NAME.find({},{KEY:1})

Example:
--------

Consider the collection mycol has the following data ?

{_id : ObjectId("507f191e810c19729de860e1"), title: "MongoDB Overview"},
{_id : ObjectId("507f191e810c19729de860e2"), title: "NoSQL Overview"},
{_id : ObjectId("507f191e810c19729de860e3"), title: "Tutorials Point Overview"}

Following example will display the title of the document while querying the document.

>db.mycol.find({},{"title":1,_id:0})
{"title":"MongoDB Overview"}
{"title":"NoSQL Overview"}
{"title":"Tutorials Point Overview"}
>

Please note _id field is always displayed while executing find() method, if you don't want this field, then you need to set it as 0.


Mangodb Limit():
----------------

To limit the records in MongoDB, you need to use limit() method. The method accepts one number type argument, which is the number of documents that you want to be displayed.

Syntax:
-------

The basic syntax of limit() method is as follows ?

>db.COLLECTION_NAME.find().limit(NUMBER)


Example:
--------

Consider the collection myycol has the following data.

{_id : ObjectId("507f191e810c19729de860e1"), title: "MongoDB Overview"},
{_id : ObjectId("507f191e810c19729de860e2"), title: "NoSQL Overview"},
{_id : ObjectId("507f191e810c19729de860e3"), title: "Tutorials Point Overview"}

Following example will display only two documents while querying the document.

>db.mycol.find({},{"title":1,_id:0}).limit(2)
{"title":"MongoDB Overview"}
{"title":"NoSQL Overview"}
>

If you don't specify the number argument in limit() method then it will display all documents from the collection.

MongoDB Skip() Method:
----------------------

Apart from limit() method, there is one more method skip() which also accepts number type argument and is used to skip the number of documents.

Syntax:
-------

The basic syntax of skip() method is as follows ?

>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)

Example:
--------

Following example will display only the second document.

>db.mycol.find({},{"title":1,_id:0}).limit(1).skip(1)
{"title":"NoSQL Overview"}
>

Please note, the default value in skip() method is 0.

Mangodb Sort():
---------------

To sort documents in MongoDB, you need to use sort() method. The method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.

Syntax:
-------

The basic syntax of sort() method is as follows ?

>db.COLLECTION_NAME.find().sort({KEY:1})

Example:
--------

Consider the collection myycol has the following data.

{_id : ObjectId("507f191e810c19729de860e1"), title: "MongoDB Overview"}
{_id : ObjectId("507f191e810c19729de860e2"), title: "NoSQL Overview"}
{_id : ObjectId("507f191e810c19729de860e3"), title: "Tutorials Point Overview"}

Following example will display the documents sorted by title in the descending order.

>db.mycol.find({},{"title":1,_id:0}).sort({"title":-1})
{"title":"Tutorials Point Overview"}
{"title":"NoSQL Overview"}
{"title":"MongoDB Overview"}
>

Please note, if you don't specify the sorting preference, then sort() method will display the documents in ascending order.


Mangodb Indexes:

Refer this link => "https://www.tutorialspoint.com/mongodb/mongodb_indexing.htm".


Aggregations:
-------------

Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an equivalent of MongoDB aggregation.

Syntax:
-------

Basic syntax of aggregate() method is as follows ?

>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)

Example:
--------

In the collection you have the following data ?

{
_id: ObjectId(7df78ad8902c)
title: 'MongoDB Overview',
description: 'MongoDB is no sql database',
by_user: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
},
{
_id: ObjectId(7df78ad8902d)
title: 'NoSQL Overview',
description: 'No sql database is very fast',
by_user: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 10
},
{
_id: ObjectId(7df78ad8902e)
title: 'Neo4j Overview',
description: 'Neo4j is no sql database',
by_user: 'Neo4j',
url: 'http://www.neo4j.com',
tags: ['neo4j', 'database', 'NoSQL'],
likes: 750
},

Now from the above collection, if you want to display a list stating how many tutorials are written by each user, then you will use the following aggregate() method ?

> db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
{ "_id" : "tutorials point", "num_tutorial" : 2 }
{ "_id" : "Neo4j", "num_tutorial" : 1 }
>

Sql equivalent query for the above use case will be select by_user, count(*) from mycol group by by_user.

In the above example, we have grouped documents by field by_user and on each occurrence of by user previous value of sum is incremented. Following is a list of available aggregation expressions.

Expression Description Example

$sum Sums up the defined value from all documents in the collection. db.mycol.aggregate([{$group : {_id : "$by_user",
num_tutorial : {$sum : "$likes"}}}])

$avg Calculates the average of all given values from all documents in db.mycol.aggregate([{$group : {_id : "$by_user",
the collection. num_tutorial : {$avg : "$likes"}}}])

$min Gets the minimum of the corresponding values from all documents in db.mycol.aggregate([{$group : {_id : "$by_user",
the collection. num_tutorial : {$min : "$likes"}}}])

$max Gets the maximum of the corresponding values from all documents in db.mycol.aggregate([{$group : {_id : "$by_user",
the collection. num_tutorial : {$max : "$likes"}}}])

$push Inserts the value to an array in the resulting document. db.mycol.aggregate([{$group : {_id : "$by_user",
url : {$push: "$url"}}}])

$addToSet Inserts the value to an array in the resulting document but does db.mycol.aggregate([{$group : {_id : "$by_user",
not create duplicates. url : {$addToSet : "$url"}}}])

$first Gets the first document from the source documents according db.mycol.aggregate([{$group : {_id : "$by_user",
to the grouping. Typically this makes only sense together with first_url : {$first : "$url"}}}])
some previously applied ?$sort?-stage.

$last Gets the last document from the source documents according to db.mycol.aggregate([{$group : {_id : "$by_user",
the grouping. Typically this makes only sense together with some last_url : {$last : "$url"}}}])
previously applied ?$sort?-stage.


Pipeline Concept:
-----------------

In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.

Following are the possible stages in aggregation framework ?

$project ? Used to select some specific fields from a collection.

$match ? This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.

$group ? This does the actual aggregation as discussed above.

$sort ? Sorts the documents.

$skip ? With this, it is possible to skip forward in the list of documents for a given amount of documents.

$limit ? This limits the amount of documents to look at, by the given number starting from the current positions.

$unwind ? This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.


Backup Mangodb Data:
--------------------

Dump MongoDB Data:
------------------

To create backup of database in MongoDB, you should use mongodump command. This command will dump the entire data of your server into the dump directory. There are many options available by which you can limit the amount of data or create backup of your remote server.

Syntax:
-------

The basic syntax of mongodump command is as follows ?

>mongodump

Lot of option available on it, for that refer below link.

Refer for full details "https://www.tutorialspoint.com/mongodb/mongodb_create_backup.htm"

Restore MongoDB data:
---------------------

To restore backup data MongoDB's mongorestore command is used. This command restores all of the data from the backup directory.

Syntax:
-------

The basic syntax of mongorestore command is ?

>mongorestore

Relationhips:
-------------

Relationships in MongoDB represent how various documents are logically related to each other. Relationships can be modeled via Embedded and Referenced approaches.


Modeling Embedded Relationships:
--------------------------------

In the embedded approach, we will embed the address document inside the user document.

> db.users.insert({
{
"_id":ObjectId("52ffc33cd85242f436000001"),
"contact": "987654321",
"dob": "01-01-1991",
"name": "Tom Benzamin",
"address": [
{
"building": "22 A, Indiana Apt",
"pincode": 123456,
"city": "Los Angeles",
"state": "California"
},
{
"building": "170 A, Acropolis Apt",
"pincode": 456789,
"city": "Chicago",
"state": "Illinois"
}
]
}
})

This approach maintains all the related data in a single document, which makes it easy to retrieve and maintain. The whole document can be retrieved in a single query such as ?

>db.users.findOne({"name":"Tom Benzamin"},{"address":1})

Note that in the above query, db and users are the database and collection respectively.

The drawback is that if the embedded dcument keeps on growing too much in size, it can impact the read/write performance.

Modeling Referenced Relationships:
----------------------------------

This is the approach of designing normalized relationship. In this approach, both the user and address documents will be maintained separately but the user document will contain a field that will reference the address document's id field.

{
"_id":ObjectId("52ffc33cd85242f436000001"),
"contact": "987654321",
"dob": "01-01-1991",
"name": "Tom Benzamin",
"address_ids": [
ObjectId("52ffc4a5d85242602e000000"),
ObjectId("52ffc4a5d85242602e000001")
]
}

As shown above, the user document contains the array field address_ids which contains ObjectIds of corresponding addresses. Using these ObjectIds, we can query the address documents and get address details from there. With this approach, we will need two queries: first to fetch the address_ids fields from user document and second to fetch these addresses from address collection.

>var result = db.users.findOne({"name":"Tom Benzamin"},{"address_ids":1})
>var addresses = db.address.find({"_id":{"$in":result["address_ids"]}})


Covered Query:
--------------

As per the official MongoDB documentation, a covered query is a query in which ?

All the fields in the query are part of an index.
All the fields returned in the query are in the same index.

Since all the fields present in the query are part of an index, MongoDB matches the query conditions and returns the result using the same index without actually looking inside the documents. Since indexes are present in RAM, fetching data from indexes is much faster as compared to fetching data by scanning documents.

Using Covered Queries:
----------------------

To test covered queries, consider the following document in the users collection ?

{
"_id": ObjectId("53402597d852426020000003"),
"contact": "987654321",
"dob": "01-01-1991",
"gender": "M",
"name": "Tom Benzamin",
"user_name": "tombenzamin"
}

We will first create a compound index for the users collection on the fields gender and user_name using the following query ?

>db.users.createIndex({gender:1,user_name:1})
{
"createdCollectionAutomatically" : false,
"numIndexesBefore" : 1,
"numIndexesAfter" : 2,
"ok" : 1
}

Now, this index will cover the following query ?

>db.users.find({gender:"M"},{user_name:1,_id:0})
{ "user_name" : "tombenzamin" }

That is to say that for the above query, MongoDB would not go looking into database documents. Instead it would fetch the required data from indexed data which is very fast.

Since our index does not include _id field, we have explicitly excluded it from result set of our query, as MongoDB by default returns _id field in every query. So the following query would not have been covered inside the index created above ?

>db.users.find({gender:"M"},{user_name:1})
{ "_id" : ObjectId("53402597d852426020000003"), "user_name" : "tombenzamin" }

Lastly, remember that an index cannot cover a query if ?

-> Any of the indexed fields is an array
-> Any of the indexed fields is a subdocument


Analyzing queries:
------------------

Analyzing queries is a very important aspect of measuring how effective the database and indexing design is. We will learn about the frequently used $explain and $hint queries.

Example:
--------
>db.users.find({gender:"M"},{user_name:1,_id:0}).explain()

It gives the full detail of the query.

Atomic Operations:
------------------

It is nothing but, select query and insert into it. For example,

Example:
--------
>db.products.findAndModify({
query:{_id:2,product_available:{$gt:0}},
update:{
$inc:{product_available:-1},
$push:{product_bought_by:{customer:"rob",date:"9-Jan-2014"}}
}
})

Indexing Limitations:
---------------------

In this chapter, we will learn about Indexing Limitations and its other components.

Extra Overhead:
---------------

Every index occupies some space as well as causes an overhead on each insert, update and delete. So if you rarely use your collection for read operations, it makes sense not to use indexes.

RAM Usage:
----------

Since indexes are stored in RAM, you should make sure that the total size of the index does not exceed the RAM limit. If the total size increases the RAM size, it will start deleting some indexes, causing performance loss.

Query Limitations:
------------------

Indexing can't be used in queries which use ?

Regular expressions or negation operators like $nin, $not, etc.
Arithmetic operators like $mod, etc.
$where clause

Hence, it is always advisable to check the index usage for your queries.

Index Key Limits:
-----------------

Starting from version 2.6, MongoDB will not create an index if the value of existing index field exceeds the index key limit.

Inserting Documents Exceeding Index Key Limit:
----------------------------------------------

MongoDB will not insert any document into an indexed collection if the indexed field value of this document exceeds the index key limit. Same is the case with mongorestore and mongoimport utilities.

Maximum Ranges:
---------------

A collection cannot have more than 64 indexes.
The length of the index name cannot be longer than 125 characters.
A compound index can have maximum 31 fields indexed.



Map-reduce:
------------

As per the MongoDB documentation, Map-reduce is a data processing paradigm for condensing large volumes of data into useful aggregated results. MongoDB uses mapReduce command for map-reduce operations. MapReduce is generally used for processing large data sets.

Read any other documentation for this.

Replication:
------------

Replication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.

Why Replication?

-> To keep your data safe
-> High (24*7) availability of data
-> Disaster recovery
-> No downtime for maintenance (like backups, index rebuilds, compaction)
-> Read scaling (extra copies to read from)
-> Replica set is transparent to the application

For full detail refer => "https://www.tutorialspoint.com/mongodb/mongodb_replication.htm".


Sharding:
---------

Sharding is the process of storing data records across multiple machines and it is MongoDB's approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.

Why Sharding?

-> In replication, all writes go to master node

-> Latency sensitive queries still go to master

-> Single replica set has limitation of 12 nodes

-> Memory can't be large enough when active dataset is big

-> Local disk is not big enough

-> Vertical scaling is too expensive 


Mongodb Commands:
-----------------

Reference Link: https://docs.mongodb.com/manual/reference/mongo-shell/
-----------------------------------------------------------------------

Help Methods and Commands        Description

help                            Show help.
db.help()                        Show help for database methods.
db.<collection>.help()            Show help on collection methods. The <collection> can be the name of an existing collection or a
                                non-existing collection.
show dbs                        Print a list of all databases on the server.
use <db>                        Switch current database to <db>. The mongo shell variable db is set to the current database.
show collections                Print a list of all collections for current database.
show users                        Print a list of users for current database.
show roles                        Print a list of all roles, both user-defined and built-in, for the current database.
show profile                    Print the five most recent operations that took 1 millisecond or more. See documentation on the database
                                profiler for more information.
show databases                    Print a list of all available datab


Queries:
--------

Reference Link:
---------------
https://docs.mongodb.com/manual/tutorial/query-documents/

Insert Query:
-------------

In which below "inventory" is collection name.

Example:
--------
db.inventory.insertMany([
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

Select All Documents in a Collection:
--------------------------------------
*) To select all documents in the collection, pass an empty document as the query filter parameter to the find method. The query filter parameter determines the select criteria:

Example:
--------
db.inventory.find()			//It is equal to ==> "SELECT * FROM inventory"

Specify Equality Condition in query:
------------------------------------
*) To specify equality conditions, use <field>:<value> expressions in the query filter document:

Syntax:
-------
{ <field1>: <value1>, ... }

Example:
--------
db.inventory.find( { status: "D" } )	//It is equal to ===> "SELECT * FROM inventory WHERE status = "D""

Specify Conditions Using Query Operators:
-----------------------------------------
*) A query filter document can use the query operators to specify conditions in the following form:

Syntax:
-------
{ <field1>: { <operator1>: <value1> }, ... }

Example:
--------
db.inventory.find( { status: { $in: [ "A", "D" ] } } )	//It is equal to ===> "SELECT * FROM inventory WHERE status in ("A", "D")"

The following example retrieves all documents from the inventory collection where status equals either "A" or "D":

Specify AND Conditions:
-----------------------
A compound query can specify conditions for more than one field in the collection's documents. Implicitly, a logical AND conjunction connects the clauses of a compound query so that the query selects the documents in the collection that match all the conditions.

The following example retrieves all documents in the inventory collection where the status equals "A" and qty is less than ($lt) 30:

Example:
--------
db.inventory.find( { status: "A", qty: { $lt: 30 } } )	//It is equal to ===> "SELECT * FROM inventory WHERE status = "A" AND qty < 30"

Specify OR Conditions:
----------------------
Using the $or operator, you can specify a compound query that joins each clause with a logical OR conjunction so that the query selects the documents in the collection that match at least one condition.

The following example retrieves all documents in the collection where the status equals "A" or qty is less than ($lt) 30:

Example:
--------
db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } )		//It is equal to ====> "SELECT * FROM inventory WHERE status = "A" OR qty < 30"

Specify AND as well as OR Conditions:
-------------------------------------
In the following example, the compound query document selects all documents in the collection where the status equals "A" and either qty is less than ($lt) 30 or item starts with the character p

Example:
--------
db.inventory.find( {
     status: "A",
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]
} )		//It is equal to ===> "SELECT * FROM inventory WHERE status = "A" AND ( qty < 30 OR item LIKE "p%")"

Distinction:
------------
Syntax:
-------
db.collection.distinct()

Below collection data:
{ "_id": 1, "dept": "A", "item": { "sku": "111", "color": "red" }, "sizes": [ "S", "M" ] }
{ "_id": 2, "dept": "A", "item": { "sku": "111", "color": "blue" }, "sizes": [ "M", "L" ] }
{ "_id": 3, "dept": "B", "item": { "sku": "222", "color": "blue" }, "sizes": "S" }
{ "_id": 4, "dept": "A", "item": { "sku": "333", "color": "black" }, "sizes": [ "S" ] }

Example:
--------
db.inventory.distinct( "dept" )	// It returns [ "A", "B" ]

Multiple Delete:
----------------
Syntax:
-------
db.collection.deleteMany()

Example: 
--------
try {
   db.orders.deleteMany( { "client" : "Crude Traders Inc." } );
} catch (e) {
   print (e);
}

It returns:
-----------
{ "acknowledged" : true, "deletedCount" : 10 }

Drop Collection:
----------------
Syntax:
-------
db.collection.drop(<options>)

Example:
--------
db.students.drop()


Count():
--------
Syntax:
-------
db.collection.count(query, options)

Example:
--------
db.collection.find( { a: 5, b: { $gt: 10 } } ).count()


Match an Embedded/Nested Document:
----------------------------------
To specify an equality condition on a field that is an embedded/nested document, use the query filter document { <field>: <value> } where <value> is the document to match.

Insert:
-------
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

For example, the following query selects all documents where the field size equals the document { h: 14, w: 21, uom: "cm" }:

Example:
--------
db.inventory.find( { size: { h: 14, w: 21, uom: "cm" } } )

Specify Equality Match on a Nested Field:
-----------------------------------------
The following example selects all documents where the field uom nested in the size field equals "in":

Example:
--------
db.inventory.find( { "size.uom": "in" } )

Specify Match using Query Operator:
-----------------------------------
A query filter document can use the query operators to specify conditions in the following form:

Syntax:
-------
{ <field1>: { <operator1>: <value1> }, ... }

The following query uses the less than operator ($lt) on the field h embedded in the size field:

Example:
--------
db.inventory.find( { "size.h": { $lt: 15 } } )

Specify AND Condition:
----------------------
The following query selects all documents where the nested field h is less than 15, the nested field uom equals "in", and the status field equals "D":

Example:
--------
db.inventory.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" } )

Query an Array:
---------------
This page provides examples of query operations on array fields using the db.collection.find() method in mongosh. The examples on this page use the inventory collection. To populate the inventory collection, run the following:

Insert Query:
-------------
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
   { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
   { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
   { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
   { item: "postcard", qty: 45, tags: ["blue"], dim_cm: [ 10, 15.25 ] }
]);

Match an Array:
---------------
To specify equality condition on an array, use the query document { <field>: <value> } where <value> is the exact array to match, including the order of the elements.

The following example queries for all documents where the field tags value is an array with exactly two elements, "red" and "blank", in the specified order:

Example:
--------
db.inventory.find( { tags: ["red", "blank"] } )

If, instead, you wish to find an array that contains both the elements "red" and "blank", without regard to order or other elements in the array, use the $all operator:

Example:
--------
db.inventory.find( { tags: { $all: ["red", "blank"] } } )

Query an Array for an Element:
------------------------------
To query if the array field contains at least one element with the specified value, use the filter { <field>: <value> } where <value> is the element value.

The following example queries for all documents where tags is an array that contains the string "red" as one of its elements:

Example:
--------
db.inventory.find( { tags: "red" } )

To specify conditions on the elements in the array field, use query operators in the query filter document:

Syntax:
-------
{ <array field>: { <operator1>: <value1>, ... } }

For example, the following operation queries for all documents where the array dim_cm contains at least one element whose value is greater than 25.

Example:
--------
db.inventory.find( { dim_cm: { $gt: 25 } } )

Specify Multiple Conditions for Array Elements:
------------------------------------------------
When specifying compound conditions on array elements, you can specify the query such that either a single array element meets these condition or any combination of array elements meets the conditions.

Query an Array with Compound Filter Conditions on the Array Elements:
---------------------------------------------------------------------
The following example queries for documents where the dim_cm array contains elements that in some combination satisfy the query conditions; e.g., one element can satisfy the greater than 15 condition and another element can satisfy the less than 20 condition, or a single element can satisfy both:

Example:
--------
db.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } )

Query for an Array Element that Meets Multiple Criteria:
--------------------------------------------------------
Use $elemMatch operator to specify multiple criteria on the elements of an array such that at least one array element satisfies all the specified criteria.

The following example queries for documents where the dim_cm array contains at least one element that is both greater than ($gt) 22 and less than ($lt) 30:

Example:
--------
db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )

Query for an Element by the Array Index Position:
-------------------------------------------------
Using dot notation, you can specify query conditions for an element at a particular index or position of the array. The array uses zero-based indexing.

The following example queries for all documents where the second element in the array dim_cm is greater than 25:

Example:
--------
db.inventory.find( { "dim_cm.1": { $gt: 25 } } )

Query an Array by Array Length:
-------------------------------
Use the $size operator to query for arrays by number of elements. For example, the following selects documents where the array tags has 3 elements.

Example:
--------
db.inventory.find( { "tags": { $size: 3 } } )

Query an Array of Embedded Documents:
-------------------------------------
This page provides examples of query operations on an array of nested documents using the db.collection.find() method in mongosh. The examples on this page use the inventory collection. To populate the inventory collection, run the following:

Insert Query:
-------------
db.inventory.insertMany( [
   { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
   { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
   { item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },
   { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);

Query for a Document Nested in an Array:
----------------------------------------
The following example selects all documents where an element in the instock array matches the specified document:

Example:
--------
db.inventory.find( { "instock": { warehouse: "A", qty: 5 } } )

Equality matches on the whole embedded/nested document require an exact match of the specified document, including the field order. For example, the following query does not match any documents in the inventory collection:

Example:
--------
db.inventory.find( { "instock": { qty: 5, warehouse: "A" } } )

Specify a Query Condition on a Field in an Array of Documents:
---------------------------------------------------------------

Specify a Query Condition on a Field Embedded in an Array of Documents:
-----------------------------------------------------------------------
If you do not know the index position of the document nested in the array, concatenate the name of the array field, with a dot (.) and the name of the field in the nested document.

The following example selects all documents where the instock array has at least one embedded document that contains the field qty whose value is less than or equal to 20:

Example:
--------
db.inventory.find( { 'instock.qty': { $lte: 20 } } )

Use the Array Index to Query for a Field in the Embedded Document:
------------------------------------------------------------------
Using dot notation, you can specify query conditions for field in a document at a particular index or position of the array. The array uses zero-based indexing.

The following example selects all documents where the instock array has as its first element a document that contains the field qty whose value is less than or equal to 20:

Example:
--------
db.inventory.find( { 'instock.0.qty': { $lte: 20 } } )

Specify Multiple Conditions for Array of Documents:
---------------------------------------------------
When specifying conditions on more than one field nested in an array of documents, you can specify the query such that either a single document meets these condition or any combination of documents (including a single document) in the array meets the conditions.

A Single Nested Document Meets Multiple Query Conditions on Nested Fields:
--------------------------------------------------------------------------
Use $elemMatch operator to specify multiple criteria on an array of embedded documents such that at least one embedded document satisfies all the specified criteria.

The following example queries for documents where the instock array has at least one embedded document that contains both the field qty equal to 5 and the field warehouse equal to A:

Example:
--------
db.inventory.find( { "instock": { $elemMatch: { qty: 5, warehouse: "A" } } } )

The following example queries for documents where the instock array has at least one embedded document that contains the field qty that is greater than 10 and less than or equal to 20:

Example:
--------
db.inventory.find( { "instock": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )

Combination of Elements Satisfies the Criteria:
-----------------------------------------------
If the compound query conditions on an array field do not use the $elemMatch operator, the query selects those documents whose array contains any combination of elements that satisfies the conditions.

For example, the following query matches documents where any document nested in the instock array has the qty field greater than 10 and any document (but not necessarily the same embedded document) in the array has the qty field less than or equal to 20:

Example:
--------
db.inventory.find( { "instock.qty": { $gt: 10,  $lte: 20 } } )

The following example queries for documents where the instock array has at least one embedded document that contains the field qty equal to 5 and at least one embedded document (but not necessarily the same embedded document) that contains the field warehouse equal to A:

Example:
--------
db.inventory.find( { "instock.qty": 5, "instock.warehouse": "A" } )


How to Handle Advanced Data Processing with MongoDB's Aggregation Framework:
----------------------------------------------------------------------------
Reference Link: https://www.freecodecamp.org/news/mongodb-aggregation-framework/

*) MongoDB has come a long way. Even though there are many NoSQL databases out there, MongoDB is the first database that comes to mind when talking about NoSQL databases. 
*) Although there always has been a bit of heat between people who like SQL and people who prefer NoSQL, the truth is, databases like MongoDB solve a different problem. 
*) And they can be really handy when handing unstructured data where manipulating the shape of data quickly and efficiently (and turning it into relevant knowledge) is more helpful than the rock-solid performance provided by old school SQL databases.
*) MongoDB comes with a powerful framework for doing this – that is, manipulating data right onto the server: the Aggregation Framework. Let's get into it and cover some quick points about it, what it is, and why it is important.

What is the Aggregation Framework?
-----------------------------------
*) The Aggregation framework is just a way to query documents in a collection in MongoDB. This framework exists because when you start working with and manipulating data, you often need to crunch collections together, modify them, pluck out fields, rename fields, concat them together, group documents by field, explode array of fields in different documents and so on. 
*) This cannot be done by the traditional querying system which MongoDB comes with (that is, the find query or update query, or any other query you might have used).
*) The simple query set in MongoDB only allows you to retrieve full or parts of individual documents. They don't really allow you to manipulate the documents on the server and then return them to your application. 

Pipeline:
---------
The Aggregation framework relies on the pipeline concept. Let's see an image which explains it in a better way:
Here, as you can see, we pick up a collection and pass it through a pipeline. This pipeline consists of certain stages where certain operators modify the documents in the collection using various techniques. Finally, the output is returned to the application calling the query.

Pipeline operators:
-------------------
In MongoDB, the pipeline is an array consisting of various operators, which take in a bunch of documents and spit out modified documents according to the rules specified by the programmer. The next operator takes in the documents spat out by the previous operator, hence, it's called a pipeline. 
You can have many operators in a pipeline, and these operators can be repeated as well, unlike regular MongoDB queries.

Pipeline Sequence Optimization:
-------------------------------
($project or $unset or $addFields or $set) + $match Sequence Optimization

Let's take a look at some common pipeline operators in MongoDB:
---------------------------------------------------------------
    $project − Used to select some specific fields from a collection.

    $match − This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.

    $group − This does the actual aggregation as discussed above.

    $sort − Sorts the documents.

    $skip − With this, it is possible to skip forward in the list of documents for a given amount of documents.

    $limit − This limits the amount of documents to look at, by the given number starting from the current positions.

    $unwind − This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.














--------------------------------------------------------------------------------------------------------------------------------------------------------------------

$sort (aggregation):
--------------------
*) Sorts all input documents and returns them to the pipeline in sorted order.

Syntax:
-------
{ $sort: { <field1>: <sort order>, <field2>: <sort order> ... } }

*) $sort takes a document that specifies the field(s) to sort by and the respective sort order. <sort order> can have one of the following values:

Value	Description
1		Sort ascending.
-1		Sort descending.

*) If sorting on multiple fields, sort order is evaluated from left to right. For example, in the form above, documents are first sorted by <field1>. Then documents with the same <field1> values are further sorted by <field2>.

Sort Consistency:
-----------------
*) MongoDB does not store documents in a collection in a particular order. When sorting on a field which contains duplicate values, documents containing those values may be returned in any order.
*) If consistent sort order is desired, include at least one field in your sort that contains unique values. The easiest way to guarantee this is to include the _id field in your sort query.


Consider the following restaurant collection:
---------------------------------------------

db.restaurants.insertMany( [
   { "_id" : 1, "name" : "Central Park Cafe", "borough" : "Manhattan"},
   { "_id" : 2, "name" : "Rock A Feller Bar and Grill", "borough" : "Queens"},
   { "_id" : 3, "name" : "Empire State Pub", "borough" : "Brooklyn"},
   { "_id" : 4, "name" : "Stan's Pizzaria", "borough" : "Manhattan"},
   { "_id" : 5, "name" : "Jane's Deli", "borough" : "Brooklyn"},
] );

The following command uses the $sort stage to sort on the borough field:

Example:
--------
db.restaurants.aggregate(
   [
     { $sort : { borough : 1 } }
   ]
)

*) In this example, sort order may be inconsistent, since the borough field contains duplicate values for both Manhattan and Brooklyn. Documents are returned in alphabetical order by borough, but the order of those documents with duplicate values for borough might not the be the same across multiple executions of the same sort. For example, here are the results from two different executions of the above command:

Output:
-------
{ "_id" : 3, "name" : "Empire State Pub", "borough" : "Brooklyn" }
{ "_id" : 5, "name" : "Jane's Deli", "borough" : "Brooklyn" }
{ "_id" : 1, "name" : "Central Park Cafe", "borough" : "Manhattan" }
{ "_id" : 4, "name" : "Stan's Pizzaria", "borough" : "Manhattan" }
{ "_id" : 2, "name" : "Rock A Feller Bar and Grill", "borough" : "Queens" }
{ "_id" : 5, "name" : "Jane's Deli", "borough" : "Brooklyn" }
{ "_id" : 3, "name" : "Empire State Pub", "borough" : "Brooklyn" }
{ "_id" : 4, "name" : "Stan's Pizzaria", "borough" : "Manhattan" }
{ "_id" : 1, "name" : "Central Park Cafe", "borough" : "Manhattan" }
{ "_id" : 2, "name" : "Rock A Feller Bar and Grill", "borough" : "Queens" }

*) While the values for borough are still sorted in alphabetical order, the order of the documents containing duplicate values for borough (i.e. Manhattan and Brooklyn) is not the same.

*) To achieve a consistent sort, add a field which contains exclusively unique values to the sort. The following command uses the $sort stage to sort on both the borough field and the _id field:

Example:
--------
db.restaurants.aggregate(
   [
     { $sort : { borough : 1, _id: 1 } }
   ]
)

*) Since the _id field is always guaranteed to contain exclusively unique values, the returned sort order will always be the same across multiple executions of the same sort.

Ascending/Descending Sort:
--------------------------
For the field or fields to sort by, set the sort order to 1 or -1 to specify an ascending or descending sort respectively, as in the following example:

Example:
--------
db.users.aggregate(
   [
     { $sort : { age : -1, posts: 1 } }
   ]
)

*) This operation sorts the documents in the users collection, in descending order according by the age field and then in ascending order according to the value in the posts field.

Text Score Metadata Sort:
-------------------------
*) For a pipeline that includes a $text search, you can sort by descending relevance score using the { $meta: "textScore" } expression. In the { <sort-key> } document, set the { $meta: "textScore" } expression to an arbitrary field name. The field name is ignored by the query system. For example:

Example:
--------
db.users.aggregate(
   [
     { $match: { $text: { $search: "operating" } } },
     { $sort: { score: { $meta: "textScore" }, posts: -1 } }
   ]
)

*) This operation uses the $text operator to match the documents, and then sorts first by the "textScore" metadata in descending order, and then by the posts field in descending order. The score field name in the sort document is ignored by the query system. In this pipeline, the "textScore" metadata is not included in the projection and is not returned as part of the matching documents. See $meta for more information.


$limit:
-------
*) Limits the number of documents passed to the next stage in the pipeline.
*) $limit takes a positive integer that specifies the maximum number of documents to pass along.
*) If using the $limit stage with any of: "$sort", sort(), findAndModify(), be sure to include at least one field in your sort that contains unique values, before passing results to the $limit stage.
*) Sorting on fields that contain duplicate values may return an inconsistent sort order for those duplicate fields over multiple executions, especially when the collection is actively receiving writes.
*) The easiest way to guarantee sort consistency is to include the _id field in your sort query.

Example:
--------
db.article.aggregate([
   { $limit : 5 }
]);

*) This operation returns only the first 5 documents passed to it by the pipeline. $limit has no effect on the content of the documents it passes.


$match (aggregation):
---------------------
Filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage.

Syntax:
-------
{ $match: { <query> } }

*) $match takes a document that specifies the query conditions. The query syntax is identical to the read operation query syntax; i.e. $match does not accept raw aggregation expressions. Instead, use a $expr query expression to include aggregation expression in $match.

Restrictions:
-------------
*) The $match query syntax is identical to the read operation query syntax; i.e. $match does not accept raw aggregation expressions. To include aggregation expression in $match, use a $expr query expression:

Syntax:
-------
{ $match: { $expr: { <aggregation expression> } } }

*) You cannot use $where in $match queries as part of the aggregation pipeline.
*) You cannot use $near or $nearSphere in $match queries as part of the aggregation pipeline. As an alternative, you can either:
*) To use $text in the $match stage, the $match stage has to be the first stage of the pipeline.

Examples:
---------
The examples use a collection named articles with the following documents:

{ "_id" : ObjectId("512bc95fe835e68f199c8686"), "author" : "dave", "score" : 80, "views" : 100 }
{ "_id" : ObjectId("512bc962e835e68f199c8687"), "author" : "dave", "score" : 85, "views" : 521 }
{ "_id" : ObjectId("55f5a192d4bede9ac365b257"), "author" : "ahn", "score" : 60, "views" : 1000 }
{ "_id" : ObjectId("55f5a192d4bede9ac365b258"), "author" : "li", "score" : 55, "views" : 5000 }
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b259"), "author" : "annT", "score" : 60, "views" : 50 }
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25a"), "author" : "li", "score" : 94, "views" : 999 }
{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25b"), "author" : "ty", "score" : 95, "views" : 1000 }

Equality Match:
---------------
The following operation uses $match to perform a simple equality match:

db.articles.aggregate(
    [ { $match : { author : "dave" } } ]
);

The $match selects the documents where the author field equals dave, and the aggregation returns the following:

{ "_id" : ObjectId("512bc95fe835e68f199c8686"), "author" : "dave", "score" : 80, "views" : 100 }
{ "_id" : ObjectId("512bc962e835e68f199c8687"), "author" : "dave", "score" : 85, "views" : 521 }

Perform a Count:
----------------
The following example selects documents to process using the $match pipeline operator and then pipes the results to the $group pipeline operator to compute a count of the documents:

Example:
--------

db.articles.aggregate( [
  { $match: { $or: [ { score: { $gt: 70, $lt: 90 } }, { views: { $gte: 1000 } } ] } },
  { $group: { _id: null, count: { $sum: 1 } } }
] );

In the aggregation pipeline, $match selects the documents where either the score is greater than 70 and less than 90 or the views is greater than or equal to 1000. These documents are then piped to the $group to perform a count. The aggregation returns the following:

Output:
-------
{ "_id" : null, "count" : 5 }



$merge (aggregation):
---------------------
Writes the results of the aggregation pipeline to a specified collection. The $merge operator must be the last stage in the pipeline.

	- Can output to a collection in the same or different database.
	- Creates a new collection if the output collection does not already exist.
	- Can incorporate results (insert new documents, merge documents, replace documents, keep existing documents, fail the operation, process documents with a custom update pipeline) into an existing collection.
	- Can output to a sharded collection. Input collection can also be sharded.
	
For a comparison with the $out stage which also outputs the aggregation results to a collection, see $merge and $out Comparison.

Syntax:
-------
$merge has the following syntax:

Syntax:
-------
{ $merge: {
     into: <collection> -or- { db: <db>, coll: <collection> },
     on: <identifier field> -or- [ <identifier field1>, ...],  // Optional
     let: <variables>,                                         // Optional
     whenMatched: <replace|keepExisting|merge|fail|pipeline>,  // Optional
     whenNotMatched: <insert|discard|fail>                     // Optional
} }

For example:
------------
{ $merge: { into: "myOutput", on: "_id", whenMatched: "replace", whenNotMatched: "insert" } }

If using all default options for $merge, including writing to a collection in the same database, you can use the simplified form:

Syntax:
-------
{ $merge: <collection> } // Output collection is in the same database

The $merge takes a document with the following fields:

Field			Description

into			The collection name as a string to output to a collection in the same database where the aggregation is run. For example:
				into: "myOutput"
				
				The database and collection name in a document to output to a collection in the specified database. For example:
				into: { db:"myDB", coll:"myOutput" }
	





$lookup (aggregation):
----------------------
*) Performs a left outer join to an unsharded collection in the same database to filter in documents from the "joined" collection for processing. To each input document, the $lookup stage adds a new array field whose elements are the matching documents from the "joined" collection. The $lookup stage passes these reshaped documents to the next stage.

Syntax:
-------
{
   $lookup:
     {
       from: <collection to join>,
       localField: <field from the input documents>,
       foreignField: <field from the documents of the "from" collection>,
       as: <output array field>
     }
}

Field			Description

from			Specifies the collection in the same database to perform the join with. The from collection cannot be sharded. For details, see Sharded Collection Restrictions.

localField		Specifies the field from the documents input to the $lookup stage. $lookup performs an equality match on the localField to the foreignField from the documents of 
				the from collection. If an input document does not contain the localField, the $lookup treats the field as having a value of null for matching purposes.

foreignField	Specifies the field from the documents in the from collection. $lookup performs an equality match on the foreignField to the localField from the input documents. If 
				a document in the from collection does not contain the foreignField, the $lookup treats the value as null for matching purposes.

as				Specifies the name of the new array field to add to the input documents. The new array field contains the matching documents from the from collection. If the 
				specified name already exists in the input document, the existing field is overwritten.
				
				
The operation would correspond to the following pseudo-SQL statement:

SELECT *, <output array field>
FROM collection
WHERE <output array field> IN (
   SELECT *
   FROM <collection to join>
   WHERE <foreignField> = <collection.localField>
);


Join Conditions and Subqueries on a Joined Collection:
------------------------------------------------------
MongoDB 3.6 adds support for:

    - Executing a pipeline on a joined collection.
    - Multiple join conditions.
    - Correlated and uncorrelated subqueries.
	
In MongoDB, a correlated subquery is a pipeline in a $lookup stage that references document fields from a joined collection. An uncorrelated subquery does not reference joined fields.

*) To perform correlated and uncorrelated subqueries with two collections, and perform other join conditions besides a single equality match, use this $lookup syntax:

Syntax:
-------
{
   $lookup:
      {
         from: <joined collection>,
         let: { <var_1>: <expression>, …, <var_n>: <expression> },
         pipeline: [ <pipeline to run on joined collection> ],
         as: <output array field>
      }
}

The operation corresponds to this pseudo-SQL statement:

SELECT *, <output array field>
FROM collection
WHERE <output array field> IN (
   SELECT <documents as determined from the pipeline>
   FROM <collection to join>
   WHERE <pipeline>
);

Field			Description

from			Specifies the collection in the same database to perform the join operation. The joined collection cannot be sharded (see Sharded Collection Restrictions).

let				Optional. Specifies variables to use in the pipeline stages. Use the variable expressions to access the fields from the joined collection's documents that are input 
				to the pipeline.
				Notes:
				------
				*) To reference variables in pipeline stages, use the "$$<variable>" syntax.
				*) The let variables can be accessed by the stages in the pipeline, including additional $lookup stages nested in the pipeline.
				*) A $match stage requires the use of an $expr operator to access the variables. The $expr operator allows the use of aggregation expressions inside of the $match syntax.
				*) Starting in MongoDB 5.0, the $eq, $lt, $lte, $gt, and $gte comparison operators placed in an $expr operator can use an index on the from collection referenced in a $lookup stage. Limitations:
				*) Other (non-$match) stages in the pipeline do not require an $expr operator to access the variables.
				*) Multikey indexes are not used.
				*) Indexes are not used for comparisons where the operand is an array or the operand type is undefined.
				*) Indexes are not used for comparisons with more than one field path operand.

pipeline		Specifies the pipeline to run on the joined collection. The pipeline determines the resulting documents from the joined collection. To return all documents, specify 
				an empty pipeline [].
				The pipeline cannot include the $out stage or the $merge stage.
				The pipeline cannot directly access the joined document fields. Instead, define variables for the joined document fields using the let option and then reference the variables in the pipeline stages.
				Notes:
				------
				*) To reference variables in pipeline stages, use the "$$<variable>" syntax.
				*) The let variables can be accessed by the stages in the pipeline, including additional $lookup stages nested in the pipeline.
				*) A $match stage requires the use of an $expr operator to access the variables. The $expr operator allows the use of aggregation expressions inside of the $match syntax.
				*) Starting in MongoDB 5.0, the $eq, $lt, $lte, $gt, and $gte comparison operators placed in an $expr operator can use an index on the from collection referenced in a $lookup stage. Limitations:
				*) Multikey indexes are not used.
				*) Indexes are not used for comparisons where the operand is an array or the operand type is undefined.
				*) Indexes are not used for comparisons with more than one field path operand.
				*) Other (non-$match) stages in the pipeline do not require an $expr operator to access the variables.
				
as				Specifies the name of the new array field to add to the joined documents. The new array field contains the matching documents from the joined collection. If the 
				specified name already exists in the joined document, the existing field is overwritten.
				
*) Starting in MongoDB 5.0, you can use a concise syntax for a correlated subquery. Correlated subqueries reference document fields from a joined "foreign" collection and the "local" collection on which the aggregate() method was run.

*) The following new concise syntax removes the requirement for an equality match on the foreign and local fields inside of an $expr operator:

Syntax:
-------
{
   $lookup:
      {
         from: <foreign collection>,
         localField: <field from local collection's documents>,
         foreignField: <field from foreign collection's documents>,
         let: { <var_1>: <expression>, …, <var_n>: <expression> },
         pipeline: [ <pipeline to run> ],
         as: <output array field>
      }
}

Example:
--------
db.orders.aggregate([
   {
     $lookup:
       {
         from: "inventory",
         localField: "item",
         foreignField: "sku",
         as: "inventory_docs"
       }
  }
])



Field			Description

from			Specifies the foreign collection in the same database to join to the local collection. The foreign collection cannot be sharded (see Sharded Collection Restrictions).

localField		*) Specifies the local documents' localField to perform an equality match with the foreign documents' foreignField.
				*) If a local document does not contain a localField value, the $lookup uses a null value for the match.

foreignField	*) Specifies the foreign documents' foreignField to perform an equality match with the local documents' localField.
				*) If a foreign document does not contain a foreignField value, the $lookup uses a null value for the match.

let				Optional. Specifies the variables to use in the pipeline stages. Use the variable expressions to access the document fields that are input to the pipeline.
				Notes:
				------
				*) To reference variables in pipeline stages, use the "$$<variable>" syntax.
				*) The let variables can be accessed by the stages in the pipeline, including additional $lookup stages nested in the pipeline.
				*) A $match stage requires the use of an $expr operator to access the variables. The $expr operator allows the use of aggregation expressions inside of the $match syntax.
				*) Starting in MongoDB 5.0, the $eq, $lt, $lte, $gt, and $gte comparison operators placed in an $expr operator can use an index on the from collection referenced in a $lookup stage. Limitations:
				*) Multikey indexes are not used.
				*) Indexes are not used for comparisons where the operand is an array or the operand type is undefined.
				*) Indexes are not used for comparisons with more than one field path operand.
				*) Other (non-$match) stages in the pipeline do not require an $expr operator to access the variables.

pipeline		Specifies the pipeline to run on the foreign collection. The pipeline returns documents from the foreign collection. To return all documents, specify an empty 
				pipeline [].
				*) The pipeline cannot include the $out or $merge stages.
				*) The pipeline cannot directly access the document fields. Instead, define variables for the document fields using the "let" option and then reference the variables in the pipeline stages.
				Notes:
				------
				*) To reference variables in pipeline stages, use the "$$<variable>" syntax.
				*) The let variables can be accessed by the stages in the pipeline, including additional $lookup stages nested in the pipeline.
				*) A $match stage requires the use of an $expr operator to access the variables. The $expr operator allows the use of aggregation expressions inside of the $match syntax.
				*) Starting in MongoDB 5.0, the $eq, $lt, $lte, $gt, and $gte comparison operators placed in an $expr operator can use an index on the from collection referenced in a $lookup stage. Limitations:
				*) Multikey indexes are not used.
				*) Indexes are not used for comparisons where the operand is an array or the operand type is undefined.
				*) Indexes are not used for comparisons with more than one field path operand.
				*) Other (non-$match) stages in the pipeline do not require an $expr operator to access the variables.
				
as				Specifies the name of the new array field to add to the foreign documents. The new array field contains the matching documents from the foreign collection. If the 
				specified name already exists in the foreign document, the existing field is overwritten.

The operation corresponds to this pseudo-SQL statement:

SELECT *, <output array field>
FROM localCollection
WHERE <output array field> IN (
   SELECT <documents as determined from the pipeline>
   FROM <foreignCollection>
   WHERE <foreignCollection.foreignField> = <localCollection.localField>
   AND <pipeline match condition>
);


*) Perform a Single Equality Join with $lookup
-----------------------------------------------

Example:
--------

Create a collection orders with these documents:

db.orders.insert([
   { "_id" : 1, "item" : "almonds", "price" : 12, "quantity" : 2 },
   { "_id" : 2, "item" : "pecans", "price" : 20, "quantity" : 1 },
   { "_id" : 3  }
])
				

Create another collection inventory with these documents:

db.inventory.insert([
   { "_id" : 1, "sku" : "almonds", "description": "product 1", "instock" : 120 },
   { "_id" : 2, "sku" : "bread", "description": "product 2", "instock" : 80 },
   { "_id" : 3, "sku" : "cashews", "description": "product 3", "instock" : 60 },
   { "_id" : 4, "sku" : "pecans", "description": "product 4", "instock" : 70 },
   { "_id" : 5, "sku": null, "description": "Incomplete" },
   { "_id" : 6 }
])

The following aggregation operation on the orders collection joins the documents from orders with the documents from the inventory collection using the fields item from the orders collection and the sku field from the inventory collection:

db.orders.aggregate([
   {
     $lookup:
       {
         from: "inventory",
         localField: "item",
         foreignField: "sku",
         as: "inventory_docs"
       }
  }
])

The operation returns these documents:

{
   "_id" : 1,
   "item" : "almonds",
   "price" : 12,
   "quantity" : 2,
   "inventory_docs" : [
      { "_id" : 1, "sku" : "almonds", "description" : "product 1", "instock" : 120 }
   ]
}
{
   "_id" : 2,
   "item" : "pecans",
   "price" : 20,
   "quantity" : 1,
   "inventory_docs" : [
      { "_id" : 4, "sku" : "pecans", "description" : "product 4", "instock" : 70 }
   ]
}
{
   "_id" : 3,
   "inventory_docs" : [
      { "_id" : 5, "sku" : null, "description" : "Incomplete" },
      { "_id" : 6 }
   ]
}

In above example, returns full records of "order" collections and also get matched records of "inventory" collections.

The operation corresponds to this pseudo-SQL statement:

SELECT *, inventory_docs
FROM orders
WHERE inventory_docs IN (
   SELECT *
   FROM inventory
   WHERE sku = orders.item
);


Use $lookup with an Array:
--------------------------
*) Starting MongoDB 3.4, if the localField is an array, you can match the array elements against a scalar foreignField without needing an $unwind stage.

For example, create an example collection classes with these documents:

db.classes.insert( [
   { _id: 1, title: "Reading is ...", enrollmentlist: [ "giraffe2", "pandabear", "artie" ], days: ["M", "W", "F"] },
   { _id: 2, title: "But Writing ...", enrollmentlist: [ "giraffe1", "artie" ], days: ["T", "F"] }
])

Create another collection members with these documents:

db.members.insert( [
   { _id: 1, name: "artie", joined: new Date("2016-05-01"), status: "A" },
   { _id: 2, name: "giraffe", joined: new Date("2017-05-01"), status: "D" },
   { _id: 3, name: "giraffe1", joined: new Date("2017-10-01"), status: "A" },
   { _id: 4, name: "panda", joined: new Date("2018-10-11"), status: "A" },
   { _id: 5, name: "pandabear", joined: new Date("2018-12-01"), status: "A" },
   { _id: 6, name: "giraffe2", joined: new Date("2018-12-01"), status: "D" }
])

The following aggregation operation joins documents in the classes collection with the members collection, matching on the members field to the name field:

db.classes.aggregate([
   {
      $lookup:
         {
            from: "members",
            localField: "enrollmentlist",
            foreignField: "name",
            as: "enrollee_info"
        }
   }
])

The operation returns the following:

{
   "_id" : 1,
   "title" : "Reading is ...",
   "enrollmentlist" : [ "giraffe2", "pandabear", "artie" ],
   "days" : [ "M", "W", "F" ],
   "enrollee_info" : [
      { "_id" : 1, "name" : "artie", "joined" : ISODate("2016-05-01T00:00:00Z"), "status" : "A" },
      { "_id" : 5, "name" : "pandabear", "joined" : ISODate("2018-12-01T00:00:00Z"), "status" : "A" },
      { "_id" : 6, "name" : "giraffe2", "joined" : ISODate("2018-12-01T00:00:00Z"), "status" : "D" }
   ]
}
{
   "_id" : 2,
   "title" : "But Writing ...",
   "enrollmentlist" : [ "giraffe1", "artie" ],
   "days" : [ "T", "F" ],
   "enrollee_info" : [
      { "_id" : 1, "name" : "artie", "joined" : ISODate("2016-05-01T00:00:00Z"), "status" : "A" },
      { "_id" : 3, "name" : "giraffe1", "joined" : ISODate("2017-10-01T00:00:00Z"), "status" : "A" }
   ]
}


Use $lookup with $mergeObjects:
-------------------------------
Changed in version 3.6: MongoDB 3.6 adds the $mergeObjects operator to combine multiple documents into a single document

Create a collection orders with these documents:

db.orders.insert([
   { "_id" : 1, "item" : "almonds", "price" : 12, "quantity" : 2 },
   { "_id" : 2, "item" : "pecans", "price" : 20, "quantity" : 1 }
])

Create another collection items with these documents:

db.items.insert([
  { "_id" : 1, "item" : "almonds", description: "almond clusters", "instock" : 120 },
  { "_id" : 2, "item" : "bread", description: "raisin and nut bread", "instock" : 80 },
  { "_id" : 3, "item" : "pecans", description: "candied pecans", "instock" : 60 }
])

The following operation first uses the $lookup stage to join the two collections by the item fields and then uses $mergeObjects in the $replaceRoot to merge the joined documents from items and orders:

db.orders.aggregate([
   {
      $lookup: {
         from: "items",
         localField: "item",    // field in the orders collection
         foreignField: "item",  // field in the items collection
         as: "fromItems"
      }
   },
   {
      $replaceRoot: { newRoot: { $mergeObjects: [ { $arrayElemAt: [ "$fromItems", 0 ] }, "$$ROOT" ] } }
   },
   { $project: { fromItems: 0 } }
])

The operation returns these documents:

{ "_id" : 1, "item" : "almonds", "description" : "almond clusters", "instock" : 120, "price" : 12, "quantity" : 2 }
{ "_id" : 2, "item" : "pecans", "description" : "candied pecans", "instock" : 60, "price" : 20, "quantity" : 1 }


Reference Link:
---------------
https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/

$addFields (aggregation):
-------------------------
*) Adds new fields to documents. $addFields outputs documents that contain all existing fields from the input documents and newly added fields.
*) Starting in version 4.2, MongoDB adds a new aggregation pipeline stage $set that is an alias for $addFields.
*) Important Notes => If the name of the new field is the same as an existing field name (including _id), $addFields overwrites the existing value of that field with the value of the specified expression.
*) $addFields appends new fields to existing documents. You can include one or more $addFields stages in an aggregation operation.

Syntax:
-------
{ $addFields: { <newField>: <expression>, ... } }

Example:
--------
Data Inserted:
--------------
{
  _id: 1,
  student: "Maya",
  homework: [ 10, 5, 10 ],
  quiz: [ 10, 8 ],
  extraCredit: 0
}
{
  _id: 2,
  student: "Ryan",
  homework: [ 5, 6, 5 ],
  quiz: [ 8, 8 ],
  extraCredit: 8
}

Query:
------
db.scores.aggregate( [
   {
     $addFields: {
       totalHomework: { $sum: "$homework" } ,
       totalQuiz: { $sum: "$quiz" }
     }
   },
   {
     $addFields: { totalScore:
       { $add: [ "$totalHomework", "$totalQuiz", "$extraCredit" ] } }
   }
] )

Output:
-------
{
  "_id" : 1,
  "student" : "Maya",
  "homework" : [ 10, 5, 10 ],
  "quiz" : [ 10, 8 ],
  "extraCredit" : 0,
  "totalHomework" : 25,
  "totalQuiz" : 18,
  "totalScore" : 43
}
{
  "_id" : 2,
  "student" : "Ryan",
  "homework" : [ 5, 6, 5 ],
  "quiz" : [ 8, 8 ],
  "extraCredit" : 8,
  "totalHomework" : 16,
  "totalQuiz" : 16,
  "totalScore" : 40
}

Example:
--------
Data inserted:
---------------
{ _id: 1, type: "car", specs: { doors: 4, wheels: 4 } }
{ _id: 2, type: "motorcycle", specs: { doors: 0, wheels: 2 } }
{ _id: 3, type: "jet ski" }

Query:
------
db.vehicles.aggregate( [
        {
           $addFields: {
              "specs.fuel_type": "unleaded"
           }
        }
   ] )
   
Output:
-------
{ _id: 1, type: "car",
   specs: { doors: 4, wheels: 4, fuel_type: "unleaded" } }
{ _id: 2, type: "motorcycle",
   specs: { doors: 0, wheels: 2, fuel_type: "unleaded" } }
{ _id: 3, type: "jet ski",
   specs: { fuel_type: "unleaded" } }
   
Overwriting an existing field:
------------------------------
Data Inserted:
--------------
{ _id: 1, dogs: 10, cats: 15 }

Query:
------
db.animals.aggregate( [
  {
    $addFields: { "cats": 20 }
  }
] )

Output:
-------
{ _id: 1, dogs: 10, cats: 20 }

*) It is possible to replace one field with another. In the following example the item field substitutes for the _id field.

Data Inserted:
--------------
{ "_id" : 1, "item" : "tangerine", "type" : "citrus" }
{ "_id" : 2, "item" : "lemon", "type" : "citrus" }
{ "_id" : 3, "item" : "grapefruit", "type" : "citrus" }

Query:
------
db.fruit.aggregate( [
  {
    $addFields: {
      _id : "$item",
      item: "fruit"
    }
  }
] )

Output:
-------
{ "_id" : "tangerine", "item" : "fruit", "type" : "citrus" }
{ "_id" : "lemon", "item" : "fruit", "type" : "citrus" }
{ "_id" : "grapefruit", "item" : "fruit", "type" : "citrus" }

*) In which above changed "_id" value and make "item" value as "fruit" as static.

Add Element to an Array:
------------------------
Data inserted:
--------------
db.scores.insertMany([
   { _id: 1, student: "Maya", homework: [ 10, 5, 10 ], quiz: [ 10, 8 ], extraCredit: 0 },
   { _id: 2, student: "Ryan", homework: [ 5, 6, 5 ], quiz: [ 8, 8 ], extraCredit: 8 }
])
*) You can use $addFields with a $concatArrays expression to add an element to an existing array field. For example, the following operation uses $addFields to replace the homework field with a new array whose elements are the current homework array concatenated with another array containing a new score [ 7 ].

Query:
------
db.scores.aggregate([
   { $match: { _id: 1 } },
   { $addFields: { homework: { $concatArrays: [ "$homework", [ 7 ] ] } } }
])

Output:
-------
{ "_id" : 1, "student" : "Maya", "homework" : [ 10, 5, 10, 7 ], "quiz" : [ 10, 8 ], "extraCredit" : 0 }
 
 
 
$bucket (aggregation): Document it later
----------------------
$bucketAuto (aggregation): Document it later
--------------------------
$collStats (aggregation): Document it later
-------------------------


$count (aggregation):
---------------------
*) New in version 3.4.
*) Passes a document to the next stage that contains a count of the number of documents input to the stage.
*) The $count stage is equivalent to the following $group + $project sequence:

Syntax:
-------
{ $count: <string> }

Data Inserted:
--------------
{ "_id" : 1, "subject" : "History", "score" : 88 }
{ "_id" : 2, "subject" : "History", "score" : 92 }
{ "_id" : 3, "subject" : "History", "score" : 97 }
{ "_id" : 4, "subject" : "History", "score" : 71 }
{ "_id" : 5, "subject" : "History", "score" : 79 }
{ "_id" : 6, "subject" : "History", "score" : 83 }

The following aggregation operation has two stages:
    - The $match stage excludes documents that have a score value of less than or equal to 80 to pass along the documents with score greater than 80 to the next stage.
    - The $count stage returns a count of the remaining documents in the aggregation pipeline and assigns the value to a field called passing_scores.

Query:
------
db.scores.aggregate(
  [
    {
      $match: {
        score: {
          $gt: 80
        }
      }
    },
    {
      $count: "passing_scores"
    }
  ]
)

Output:
-------
{ "passing_scores" : 4 }


$currentOp (aggregation): Document it later
-------------------------
$facet (aggregation): Document it later
---------------------

$group (aggregation):
---------------------
Groups input documents by the specified _id expression and for each distinct grouping, outputs a document. The _id field of each output document contains the unique group by value.

Syntax:
-------
{
  $group:
    {
      _id: <expression>, // Group By Expression
      <field1>: { <accumulator1> : <expression1> },
      ...
    }
 }
 
Field        Description
-----        -----------
_id            Required. If you specify an _id value of null, or any other constant value, the $group stage calculates accumulated values for
            all the input documents as a whole. See example of Group by Null.
field        Optional. Computed using the accumulator operators.

Accumulator Operator:
---------------------
Name                    Description
----                    ------------
$accumulator            Returns the result of a user-defined accumulator function.
$addToSet                Returns an array of unique expression values for each group. Order of the array elements is undefined. Changed in
                        version 5.0: Available in $setWindowFields stage.
$avg                    Returns an average of numerical values. Ignores non-numeric values. Changed in version 5.0: Available in
                        $setWindowFields stage.
$count                    Returns the number of documents in a group. Distinct from the $count pipeline stage. New in version 5.0: Available in
                        $group and $setWindowFields stages.
$first                    Returns a value from the first document for each group. Order is only defined if the documents are sorted. Distinct
                        from the $first array operator. Changed in version 5.0: Available in $setWindowFields stage.
$last                    Returns a value from the last document for each group. Order is only defined if the documents are sorted. Distinct
                        from the $last array operator. Changed in version 5.0: Available in $setWindowFields stage.
$max                    Returns the highest expression value for each group. Changed in version 5.0: Available in $setWindowFields stage.
$mergeObjects            Returns a document created by combining the input documents for each group.
$min                    Returns the lowest expression value for each group. Changed in version 5.0: Available in $setWindowFields stage.
$push                    Returns an array of expression values for documents in each group. Changed in version 5.0: Available in
                        $setWindowFields stage.
$stdDevPop                Returns the population standard deviation of the input values. Changed in version 5.0: Available in $setWindowFields
                        stage.
$stdDevSamp                Returns the sample standard deviation of the input values. Changed in version 5.0: Available in $setWindowFields stage.
$sum                    Returns a sum of numerical values. Ignores non-numeric values. Changed in version 5.0: Available in $setWindowFields
                        stage.
                        
Data Inserted:
--------------
db.sales.insertMany([
  { "_id" : 1, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("2"), "date" : ISODate("2014-03-01T08:00:00Z") },
  { "_id" : 2, "item" : "jkl", "price" : NumberDecimal("20"), "quantity" : NumberInt("1"), "date" : ISODate("2014-03-01T09:00:00Z") },
  { "_id" : 3, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" : NumberInt( "10"), "date" : ISODate("2014-03-15T09:00:00Z") },
  { "_id" : 4, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" :  NumberInt("20") , "date" : ISODate("2014-04-04T11:21:39.736Z") },
  { "_id" : 5, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("10") , "date" : ISODate("2014-04-04T21:23:13.331Z") },
  { "_id" : 6, "item" : "def", "price" : NumberDecimal("7.5"), "quantity": NumberInt("5" ) , "date" : ISODate("2015-06-04T05:08:13Z") },
  { "_id" : 7, "item" : "def", "price" : NumberDecimal("7.5"), "quantity": NumberInt("10") , "date" : ISODate("2015-09-10T08:43:00Z") },
  { "_id" : 8, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("5" ) , "date" : ISODate("2016-02-06T20:20:13Z") },
])

Query:    //It is equal to => "SELECT COUNT(*) AS count FROM sales"
------
db.sales.aggregate( [
  {
    $group: {
       _id: null,
       count: { $count: { } }
    }
  }
] )

Output:
-------
{ "_id" : null, "count" : 8 }

Another Query:
--------------
db.sales.aggregate( [ { $group : { _id : "$item" } } ] )

Output:
-------
{ "_id" : "abc" }
{ "_id" : "jkl" }
{ "_id" : "def" }
{ "_id" : "xyz" }

Another Query:    //It is equal to ==> "SELECT item, Sum(( price * quantity )) AS totalSaleAmount FROM sales GROUP  BY item HAVING totalSaleAmount >= 100"
--------------
db.sales.aggregate(
  [
    // First Stage
    {
      $group :
        {
          _id : "$item",
          totalSaleAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } }
        }
     },
     // Second Stage
     {
       $match: { "totalSaleAmount": { $gte: 100 } }
     }
   ]
 )
 
Output:
-------
{ "_id" : "abc", "totalSaleAmount" : NumberDecimal("170") }
{ "_id" : "xyz", "totalSaleAmount" : NumberDecimal("150") }
{ "_id" : "def", "totalSaleAmount" : NumberDecimal("112.5") }


$unionWith (aggregation):
-------------------------

Reference Link:
---------------
https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/

Performs a union of two collections; i.e. $unionWith combines pipeline results from two collections into a single result set. The stage outputs the combined result set (including duplicates) to the next stage.

Syntax:
-------
{ $unionWith: { coll: "<collection>", pipeline: [ <stage1>, ... ] } }

*) To include all documents from the specified collection without any processing, you can use the simplified form:

Syntax:
-------
{ $unionWith: "<collection>" }  // Include all documents from the specified collection

The $unionWith stage takes a document with the following fields:

Field        Description
coll        The collection or view whose pipeline results you wish to include in the result set.
pipeline    Optional. An aggregation pipeline to apply to the specified coll.
            [ <stage1>, <stage2>, ...]
            The pipeline cannot include the $out and $merge stages.
            
The $unionWith operation would correspond to the following SQL statement:

SELECT * FROM Collection1 WHERE ... UNION ALL SELECT * FROM Collection2 WHERE ...

Considerations:
---------------
Duplicates Results:
-------------------
The combined results from the previous stage and the $unionWith stage can include duplicates.

For example, create a suppliers collection:

Example:
--------
db.suppliers.insertMany([
  { _id: 1, supplier: "Aardvark and Sons", state: "Texas" },
  { _id: 2, supplier: "Bears Run Amok.", state: "Colorado"},
  { _id: 3, supplier: "Squid Mark Inc. ", state: "Rhode Island" },
])

db.warehouses.insertMany([
  { _id: 1, warehouse: "A", region: "West", state: "California" },
  { _id: 2, warehouse: "B", region: "Central", state: "Colorado"},
  { _id: 3, warehouse: "C", region: "East", state: "Florida" },
])

The following aggregation which combines the results from the state field projection from the suppliers collection with the results from the state field projection from the warehouse collection:

db.suppliers.aggregate([
   { $project: { state: 1, _id: 0 } },
   { $unionWith: { coll: "warehouses", pipeline: [ { $project: { state: 1, _id: 0 } } ]} }
])

As can be seen from the returned documents, the result set contains duplicates:

{ "state" : "Texas" }
{ "state" : "Colorado" }
{ "state" : "Rhode Island" }
{ "state" : "California" }
{ "state" : "Colorado" }
{ "state" : "Florida" }

To remove the duplicates, you can include a $group stage to group by the state field:

db.suppliers.aggregate([
   { $project: { state: 1, _id: 0 } },
   { $unionWith: { coll: "warehouses", pipeline: [ { $project: { state: 1, _id: 0 } } ]} },
   { $group: { _id: "$state" } }
])

The result set no longer contains duplicates:

{ "_id" : "California" }
{ "_id" : "Texas" }
{ "_id" : "Florida" }
{ "_id" : "Colorado" }
{ "_id" : "Rhode Island" }



authController.js
-----------------

import jwt from 'jsonwebtoken';
import { getDBConnection } from '../config/db.js';

export const verifyToken = async(req, res, next) => {
    let token;
    let err;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(' ')[1];
            const decoded = await jwt.verify(token, process.env.JWT_SECRET);
            const db = await getDBConnection();
            const usersRef = await db.collection('users').doc(decoded.user_id);
            const doc = await usersRef.get();
            if(!doc.exists) {
                err = new Error('Invalid token.');
                next(err);
            } else {
                next();
            }
        } catch (error) {
            res.status(401)
            err = new Error(error.message);
            next(error);
        }
    }

    if (!token) {
        res.status(401);
        err = new Error('Not authorized, no token');
        next(err);
    }
}

export const generateToken = (user_id) => {
    return jwt.sign({ user_id:  user_id}, process.env.JWT_SECRET, { expiresIn: '20h' }, { algorithm: 'RS256'});
};

export const getUserId = async(req) => {
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(' ')[1];
            const decoded = await jwt.verify(token, process.env.JWT_SECRET);
            return decoded.user_id;
        } catch (error) {
            return false;
        }
    }
    if (!token) {
        return false;
    }
}


-------------------------------------------------------------------------------

    'rooms.*.room_name': {
        trim: true,
        notEmpty: {
            errorMessage: "City name required."
        },
        isLength: {
            options: {
                min: 3,
                max: 100
            },
            errorMessage: "Length must be greater or equal to 3 characters or else less or equal to 100 characters."
        },
        
        custom: {
            options: (value, { req, location, path }) => {
                if(req.body.type_of_asset == 1 || req.body.type_of_asset == 2) {    //1 => 'House', 2 => 'Appartment'
                    if(value == '') {
                        return Promise.reject('Room name required.');
                    } else {
                        return Promise.resolve(true);
                    }
                }
            }
        }
    }

export const createCityValidationSchema = {
    email: {
        trim: true,
        notEmpty: {
            errorMessage: "Email is required."
        },
        isEmail: {
            errorMessage: "Invalid email address."
        },
        custom: {
            options: (value, { req, location, path }) => {
                return Users.find({
                    email: value,
                    password: req.body.password
                }).then(user => {
                    if (user.length > 0) {
                        return Promise.resolve(true);
                    } else {
                        return Promise.reject('Invalid credential.');
                    }
                })
            }
        }
    },
    password: {
        trim: true,
        notEmpty: {
            errorMessage: "Password is required."
        },
        isLength: {
            options: {
                min: 6,
                max: 50
            },
            errorMessage: "Password characters must be greater then 6 and less then 50"
        }
    }
}
